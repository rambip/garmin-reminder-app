<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mobile SDK for iOS - Garmin Connect IQ Documentation</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; }
        h1 { color: #333; }
        pre { background-color: #f5f5f5; padding: 10px; border-radius: 4px; overflow: auto; }
        code { font-family: monospace; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; }
        th { background-color: #f2f2f2; }
        img { max-width: 100%; }
    </style>
</head>
<body>
    <h1>Mobile SDK for iOS</h1>
    <div class="c0123 c0126">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><meta charset="utf-8"/><meta content="(C) Copyright 2025" name="copyright"/><meta content="(C) Copyright 2025" name="DC.rights.owner"/><meta content="topic" name="DC.type"/><meta content="HTML5" name="DC.format"/><meta content="mobile-sdk-for-ios" name="DC.identifier"/><link href="../../commonltr.css" rel="stylesheet" type="text/css"/><title>Mobile SDK for iOS</title><main role="main"><article aria-labelledby="ariaid-title1" role="article"><article aria-labelledby="ariaid-title1" class="nested0" id="mobile-sdk-for-ios"><h1 class="title topictitle1" id="ariaid-title1">Mobile SDK for iOS</h1><div class="body"><p class="p">The Connect IQ Mobile SDK allows companion iOS applications to be created that interact with Monkey C applications running on Garmin wearable devices. This allows feature-rich user experiences to be built by retrieving remote data or offloading resource-intensive tasks from the wearable device to the iOS device. This document will guide you through adding the Mobile SDK to an iOS project, as well as introducing the SDK’s API and how to communicate with your Monkey C apps.</p></div><article aria-labelledby="ariaid-title2" class="topic nested1" id="configuring-a-project-to-use-the-mobile-sdk"><h2 class="title topictitle2" id="ariaid-title2">Configuring a project to use the Mobile SDK</h2><div class="body"></div><article aria-labelledby="ariaid-title3" class="topic nested2" id="add-the-framework-to-the-project"><h3 class="title topictitle3" id="ariaid-title3">Add the framework to the project</h3><div class="body"><p class="p">The Mobile SDK for iOS is distributed as an iOS framework package and can be found at <a class="xref" href="https://github.com/garmin/connectiq-companion-app-sdk-ios" target="_blank">Garmin GitHub repo for Connect IQ Mobile SDK</a>. To enable the framework,
add an entry to the <code class="ph codeph">Project &gt; Package Dependencies</code> panel. To do this, click the + at the bottom of the Packages list.</p><img alt="Adding a framework to the iOS project" class="image" src="/connect-iq/resources/programmers-guide/ios-image1.png"/><br/><p class="p">You will be presented with a dialog box to choose which package to add as dependency. In the search box enter "https://github.com/garmin/connectiq-companion-app-sdk-ios"
<img alt="" class="image" src="/connect-iq/resources/programmers-guide/ios-image2.png"/><br/></p><article aria-labelledby="ariaid-title4" class="topic nested3" id="embed-the-connectiq-framework-as-a-binary"><h4 class="title topictitle4" id="ariaid-title4">Embed the ConnectIQ framework as a binary</h4><div class="body"><p class="p">To allow a project to build with the Mobile SDK, embed the framework as a binary for each of the project’s targets by checking the box against each of the targets and click <code class="ph codeph">Add Package</code>.</p><img alt="Embedding the framework as a binary" class="image" src="/connect-iq/resources/programmers-guide/ios-image3.png"/><br/></div></article><article aria-labelledby="ariaid-title5" class="topic nested3" id="add-required-linker-flags"><h4 class="title topictitle4" id="ariaid-title5">Add required linker flags</h4><div class="body"><p class="p">The Mobile SDK for iOS utilizes category methods internally. When importing a library that uses category methods, an additional flag must be specified to allow the library to be linked correctly. To do this, add the <code class="ph codeph">–ObjC</code> flag to the <code class="ph codeph">Target &gt; Build Settings &gt; Linking &gt; Other Linker Flags</code> setting.</p><img alt="Setting the linker flags for the target" class="image" src="/connect-iq/resources/programmers-guide/ios-image4.png"/><br/></div></article><article aria-labelledby="ariaid-title6" class="topic nested3" id="register-a-url-scheme"><h4 class="title topictitle4" id="ariaid-title6">Register a URL scheme</h4><div class="body"><p class="p">Unlike the Mobile SDK for Android, apps created with the Mobile SDK for iOS are standalone apps and do not directly rely on Garmin Connect Mobile (GCM) to communicate with a wearable device. They do, however, require GCM to initially discover Connect IQ-compatible devices that are available for communication, or to install Monkey C applications on the wearable device. The companion app and GCM exchange information by launching each other via the iOS URL scheme system. To facilitate this, a URL scheme that GCM can send data to must be registered by the app. To do this, add an entry to the <code class="ph codeph">Target &gt; Info &gt; URL Types</code> panel. A string that is not likely to collide with any other apps on the iOS device should be chosen. See the Apple documentation for more information on <a class="xref" href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW1" target="_blank">custom URL schemes</a>.</p><img alt="Registering the URL scheme for the target" class="image" src="/connect-iq/resources/programmers-guide/ios-image5.png"/><br/><p class="p">If you are compiling against the iOS 9 SDK or above you will need to add an entry for <code class="ph codeph">gcm-ciq</code> to <a class="xref" href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-SW14" target="_blank">LSApplicationQueriesSchemes</a> in your app’s Info.plist. This is needed to ensure that the SDK can verify if GCM is installed. If this key is not present in your Info.plist it will need to be added.</p><p class="p">If your project doesn't already set <a class="xref" href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html" target="_blank">CFBundleDisplayName</a> in your app’s Info.plist, you will need to add a definition. You can set this to <code class="ph codeph">${PRODUCT_NAME}</code> if you are unsure what value to use.</p></div></article><article aria-labelledby="ariaid-title7" class="topic nested3" id="set-bluetooth-usage-description"><h4 class="title topictitle4" id="ariaid-title7">Set Bluetooth usage description</h4><div class="body"><p class="p">Starting in iOS 10 it is required to set strings explaining the usage of BLE peripheral access. The <a class="xref" href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW20" target="_blank">NSBluetoothPeripheralUsageDescription</a> key must be set in Info.plist to explain your app's usage of BLE to be accepted by iTunes Connect. If this key is not present in your Info.plist it will need to be added.</p></div></article><article aria-labelledby="ariaid-title8" class="topic nested3" id="set-background-execution-mode-optional"><h4 class="title topictitle4" id="ariaid-title8">Set background execution mode (optional)</h4><div class="body"><p class="p">The iOS system allows apps that communicate with Bluetooth devices to be woken up to execute in the background when a connected device has data to send. This can be useful for companion apps that process requests for their respective Monkey C applications on a wearable device. To enable this behavior, turn on the <code class="ph codeph">Uses Bluetooth LE accessories</code> option in the <code class="ph codeph">Target &gt; Capabilities &gt; Background Modes</code> panel.</p><img alt="Optionally setting the background execution mode for the target" class="image" src="/connect-iq/resources/programmers-guide/ios-image6.png"/><br/></div></article></div><article aria-labelledby="ariaid-title9" class="topic nested3" id="initializing-the-sdk"><h4 class="title topictitle4" id="ariaid-title9">Initializing the SDK</h4><div class="body"><p class="p">All interaction with the Mobile SDK is done through the <code class="ph codeph">ConnectIQ</code> class. This class must be initialized during app startup with the project’s URL scheme and a UI override delegate. Typically this is done within the app delegate’s <code class="ph codeph">application:didFinishLaunchingWithOptions:</code> method.</p><pre class="pre codeblock objective-c"><code>[[ConnectIQ sharedInstance] initializeWithUrlScheme:@"exapp-123456"
                                 uiOverrideDelegate:self];</code></pre><p class="p">The URL scheme should be the same string chosen in Step 4 of <em class="ph i">Configuring a project to use the Mobile SDK</em>.
When invoking a method of the <code class="ph codeph">ConnectIQ</code> class that requires GCM to be installed and it is not present on the iOS system, by default an alert dialog will be shown to the user that allows them to go to the Apple App Store page for GCM to install it. By passing an instance of an object that conforms to the <code class="ph codeph">IQUIOverrideDelegate</code> protocol here, custom behavior or a specialized UI may be specified in this case. To use the default alert dialog and behavior, pass <code class="ph codeph">nil</code>.</p></div></article><article aria-labelledby="ariaid-title10" class="topic nested3" id="implementing-a-ui-override-delegate"><h4 class="title topictitle4" id="ariaid-title10">Implementing a UI override delegate</h4><div class="body"><p class="p">If a UI override delegate was specified and an action was performed that requires GCM to be installed, the <code class="ph codeph">ConnectIQ</code> class will call the <code class="ph codeph">needsToInstallConnectMobile</code> method on that delegate. The app should inform the user that GCM is required for this action and give the user the option to open the Apple App Store page for GCM or to cancel the action that triggered it. If the user chooses to install GCM, the <code class="ph codeph">showAppStoreForConnectMobile</code> method may be called.</p><pre class="pre codeblock objective-c"><code>- (void)needsToInstallConnectMobile {
    // Show alert to user with choice to install GCM
    if (alert.result == YES) {
       [[ConnectIQ sharedInstance] showAppStoreForConnectMobile];
    }
}</code></pre><p class="p">Note that this example is synchronous, but if UI is shown to the user, the <code class="ph codeph">showAppStoreForConnectMobile</code> method should be called as a result of user input instead of directly in the <code class="ph codeph">needsToInstallConnectMobile</code> method.</p></div></article></article><article aria-labelledby="ariaid-title11" class="topic nested2" id="working-with-devices"><h3 class="title topictitle3" id="ariaid-title11">Working With Devices</h3><div class="body"></div><article aria-labelledby="ariaid-title12" class="topic nested3" id="finding-connect-iq-compatible-devices"><h4 class="title topictitle4" id="ariaid-title12">Finding Connect IQ-compatible devices</h4><div class="body"><p class="p">The Mobile SDK for iOS can communicate directly with Connect IQ-compatible devices over Bluetooth. However, it must first know which devices are available. To accomplish this, a companion app must call the <code class="ph codeph">showConnectIQDeviceSelection</code> method.</p><pre class="pre codeblock objective-c"><code>[[ConnectIQ sharedInstance] showConnectIQDeviceSelection];</code></pre><p class="p">This method launches GCM to the foreground and allows the user to choose which paired Connect IQ-compatible devices to share with the companion app. If GCM is not installed and a UI override delegate was set, its <code class="ph codeph">needsToInstallConnectMobile</code> will be called.</p><p class="p">!!! Note
Note that by launching GCM, this method causes the companion app to go into the background, possibly resulting in the app being suspended. <strong class="ph b">The companion app should expect to be suspended when calling this method.</strong></p><p class="p">Once the user has selected which of the paired devices to share with the companion app, GCM will launch the companion app (via its registered URL scheme), passing the list of devices as serialized URL query items. The companion app should override its app delegate’s <code class="ph codeph">application:openURL:sourceApplication:annotation:</code> method to listen for this. The companion app may then call the <code class="ph codeph">parseDeviceSelectionResponseFromURL:</code> method to extract the query items into an <code class="ph codeph">NSArray</code> of <code class="ph codeph">IQDevice</code> objects that it can use with the Mobile SDK.</p><pre class="pre codeblock objective-c"><code>- (BOOL)application:(UIApplication *)application
            openURL:(NSURL *)url
  sourceApplication:(NSString *)sourceApplication
         annotation:(id)annotation {
    if ([url.scheme isEqualToString:ReturnURLScheme] &amp;&amp;
        [sourceApplication isEqualToString:IQGCMBundle]) {

        NSArray *devices = [[ConnectIQ sharedInstance]
                             parseDeviceSelectionResponseFromURL:url];
        if (devices != nil) {
            [self.devices removeAllObjects];
            for (IQDevice *device in devices) {
                self.devices[device.uuid] = device;
            }
            return YES;
        }
    }
    return NO;
}</code></pre><p class="p">Note that in this example, the parsed devices are stored to a dictionary for later use within the app, but are not cached in any kind of persistent storage.</p><p class="p">!!!Note
To avoid needing to launch GCM excessively to discover devices, <strong class="ph b">companion apps should cache devices to persistent storage.</strong>
When a list of devices is returned by GCM, companion apps should clear all previously cached references to devices they may have known about. <strong class="ph b">Always use only the latest list of devices that the user has authorized.</strong></p></div></article><article aria-labelledby="ariaid-title13" class="topic nested3" id="listening-for-device-events"><h4 class="title topictitle4" id="ariaid-title13">Listening for device events</h4><div class="body"><p class="p">Once the companion app has one or more <code class="ph codeph">IQDevice</code> instances from GCM, it may register with the <code class="ph codeph">ConnectIQ</code> class to receive notifications when that device’s connection status changes by calling <code class="ph codeph">registerForDeviceEvents:delegate:</code>.</p><pre class="pre codeblock objective-c"><code>[[ConnectIQ sharedInstance] registerForDeviceEvents:device
                                           delegate:self];</code></pre><p class="p">The delegate passed in must be an instance of a class that conforms to the <code class="ph codeph">IQDeviceEventDelegate</code> protocol. Once registered, the delegate’s <code class="ph codeph">deviceStatusChanged:status:</code> method will be invoked when the device’s connection status changes. The <code class="ph codeph">getDeviceStatus:</code> method may also be called to get the current connection status of the device. These methods both return a device’s status as an <code class="ph codeph">IQDeviceStatus</code> value.</p><p class="p">!!! Note
A companion app must register to receive device events before calling methods that operate on devices or apps, such as <code class="ph codeph">getDeviceStatus:</code> or <code class="ph codeph">sendMessage:toApp:progress:completion:</code>.</p><p class="p">To stop listening for device events, a companion app may call either the <code class="ph codeph">unregisterForDeviceEvents:delegate:</code> or <code class="ph codeph">unregisterForAllDeviceEvents:</code> method.</p><pre class="pre codeblock objective-c"><code>// Stop listening to a single device
[[ConnectIQ sharedInstance] unregisterForDeviceEvents:device
                                             delegate:self];
// ... or unregister all devices for this listener
[[ConnectIQ sharedInstance] unregisterForAllDeviceEvents:self];</code></pre></div></article></article><article aria-labelledby="ariaid-title14" class="topic nested2" id="working-with-apps"><h3 class="title topictitle3" id="ariaid-title14">Working With Apps</h3><div class="body"></div><article aria-labelledby="ariaid-title15" class="topic nested3" id="creating-an-app-instance"><h4 class="title topictitle4" id="ariaid-title15">Creating an app instance</h4><div class="body"><p class="p">Apps are represented in the Mobile SDK as instances of the <code class="ph codeph">IQApp</code> class. An instance of the <code class="ph codeph">IQApp</code> class represents a single app on a single device. This means that in order to work with an app that’s installed on two different devices, a companion app will need two instances of the <code class="ph codeph">IQApp</code> class with the same app ID, one for each device. To create an app instance, use the <code class="ph codeph">IQApp</code> class’s <code class="ph codeph">appWithUUID:device:</code> method.</p><pre class="pre codeblock objective-c"><code>NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:@”&lt;YourAppID&gt;”];
IQApp *app = [IQApp appWithUUID:uuid device:device];</code></pre></div></article><article aria-labelledby="ariaid-title16" class="topic nested3" id="requesting-an-apps-status"><h4 class="title topictitle4" id="ariaid-title16">Requesting an app’s status</h4><div class="body"><p class="p">Once an <code class="ph codeph">IQApp</code> instance has been created that links an app ID to an <code class="ph codeph">IQDevice</code> instance, a companion app may request the status of the app on that device by calling the <code class="ph codeph">getAppStatus:completion:</code> method.</p><pre class="pre codeblock objective-c"><code>[[ConnectIQ sharedInstance] getAppStatus:app
                              completion:^(IQAppStatus *appStatus) {
    if (appStatus != nil &amp;&amp; appStatus.isInstalled) {
        NSLog(@”App is installed! Version: %d”, appStatus.version);
    }
}];</code></pre><p class="p">This method communicates with the device over Bluetooth, and therefore is asynchronous. The completion block will be invoked when the device responds, or the request times out.
If the request is successful, the completion block will be invoked with an instance of the <code class="ph codeph">IQAppStatus</code> class. A companion app may inspect this status to discover if the app is installed on the device, and if so, what the version of that app is. A companion app could then potentially show a UI that recommends that the user upgrade the app on the device.
If the device is not currently connected or the request times out, the completion block will be invoked with a <code class="ph codeph">nil</code> status.</p></div></article><article aria-labelledby="ariaid-title17" class="topic nested3" id="installing-upgrading-or-managing-an-app"><h4 class="title topictitle4" id="ariaid-title17">Installing, upgrading, or managing an app</h4><div class="body"><p class="p">If a companion app determines that an app is out of date or not installed, it may allow the user to install or upgrade that app by launching the Connect IQ store within GCM. To do this, simply call the <code class="ph codeph">showConnectIQStoreForApp:</code> method.</p><pre class="pre codeblock objective-c"><code>[[ConnectIQ sharedInstance] showConnectIQStoreForApp:app];</code></pre><p class="p">A companion app may also call this method even if the app is installed and up-to-date on the device, to allow the user to manage or uninstall the app from the device.</p><p class="p">!!! Note
Like the <code class="ph codeph">showConnectIQDeviceSelection</code> method, by launching GCM, this method causes the companion app to go into the background, possibly resulting in the app being suspended. <strong class="ph b">The companion app should expect to be suspended when calling this method.</strong></p></div></article><article aria-labelledby="ariaid-title18" class="topic nested3" id="opening-an-app-on-the-garmin-device"><h4 class="title topictitle4" id="ariaid-title18">Opening an app on the Garmin device</h4><div class="body"><p class="p">A companion app can request that a CIQ app be opened on the target device. When doing so a prompt will be displayed to the user on the Garmin device to see if they app should be opened. If the user chooses to open the app then it will be immediately opened. This can be accomplished by calling the <code class="ph codeph">openAppRequest:</code> method.</p><pre class="pre codeblock objective-c"><code>[[ConnectIQ sharedInstance] openAppRequest:app
                                completion:^(IQSendMessageResult result) {
    switch(result) {
        case IQSendMessageResult_Success: NSLog(@”Popup was displayed”); break;
        case IQSendMessageResult_Failure_PromptNotDisplayed: NSLog(@”Popup was
                displayed”); break;
        case IQSendMessageResult_Failure_AppAlreadyRunning: NSLog(@”Popup was
                displayed”); break;
    }
}];</code></pre></div></article><article aria-labelledby="ariaid-title19" class="topic nested3" id="sending-messages"><h4 class="title topictitle4" id="ariaid-title19">Sending messages</h4><div class="body"><p class="p">Once a companion app has determined that an app is installed on a connected device, the companion app may send messages over Bluetooth to that app’s mailbox by calling the <code class="ph codeph">sendMessage:toApp:progress:completion:</code> method. This method takes an object as a message, an <code class="ph codeph">IQApp</code> as the destination, and two blocks -- one that is invoked periodically as the data transfer progresses, and one that is invoked once the transfer is finished.</p><pre class="pre codeblock objective-c"><code>NSArray *message = @[@”hello pi”, @(3.14159)];
[[ConnectIQ sharedInstance] sendMessage:message
                                  toApp:app
                               progress:^(uint32_t sent, uint32_t total) {
    float percent = 100 * sent / (float)total;
    NSLog(@"%02.2f%% - %u/%u", percent, sent, total);
} completion:^(IQSendMessageResult result) {
    NSLog(@"Send message finished with result %@",
        NSStringFromSendMessageResult(result));
}];</code></pre><p class="p">!!! Note
The message object that is passed to this method is first converted by the SDK into a Monkey C-compatible type, and is then sent to the app’s mailbox on the device. Therefore, <strong class="ph b">only Objective-C types that can be directly translated to comparable Monkey C types are valid.</strong></p><p class="p">Valid message types include <code class="ph codeph">NSString</code>, <code class="ph codeph">NSNumber</code>, <code class="ph codeph">NSArray</code>, <code class="ph codeph">NSDictionary</code>, and <code class="ph codeph">NSNull</code>. Take advantage of nesting other types inside an <code class="ph codeph">NSArray</code> or <code class="ph codeph">NSDictionary</code> to form complex messages. Values contained in <code class="ph codeph">NSNumber</code> objects will be converted to the most appropriate Monkey C value type on the device.</p><p class="p">!!! Note
Keep in mind that the wearable devices have limited memory and processing power compared to an iOS device. <strong class="ph b">Messages should be as small as possible.</strong> However, sending frequent small messages can incur performance and battery life costs. Therefore, it is more desirable to send occasional large messages than it is to frequently send many tiny messages. <strong class="ph b">Companion apps should aim to balance the costs of memory and performance by sending messages only when necessary and keeping message size to a minimum.</strong></p></div></article><article aria-labelledby="ariaid-title20" class="topic nested3" id="receiving-messages"><h4 class="title topictitle4" id="ariaid-title20">Receiving messages</h4><div class="body"><p class="p">A companion app may register to receive messages that are sent from an app on a device by calling the <code class="ph codeph">registerForAppMessages:delegate:</code> method. This method takes an <code class="ph codeph">IQApp</code> to listen for messages from, and an instance of an object that conforms to the <code class="ph codeph">IQAppMessageDelegate</code> protocol as the listener. After registering, when a message from that app is successfully received, the <code class="ph codeph">receivedMessage:fromApp:</code> method will be called on the listener.
To stop listening for app messages, a companion app may call either the unregisterForAppMessages:delegate: or unregisterForAllAppMessages: method.</p><pre class="pre codeblock objective-c"><code>- (void)viewWillAppear:(BOOL)animated {
    [[ConnectIQ sharedInstance] registerForAppMessages:self.app delegate:self];
}

- (void)viewDidDisappear:(BOOL)animated {
    [[ConnectIQ sharedInstance] unregisterForAllAppMessages:self];
}

- (void)receivedMessage:(id)message fromApp:(IQApp *)app {
    NSLog(@"Received message from app %@: '%@'", app, message);
}</code></pre><p class="p">!!! Note
A companion app may register to receive messages from multiple apps across many devices. However, <strong class="ph b">multiple companion apps should never register to receive messages from the same app</strong>. The nature of Bluetooth communication on iOS prevents the Mobile SDK from determining which companion app to deliver the message to. Therefore, undefined behavior will result from multiple companion apps registering to receive messages from the same app.</p><img alt="Mulitple watch apps can comunicate with a single phone app" class="image" src="/connect-iq/resources/programmers-guide/ios-image8.png"/><br/><img alt="A single watch app cannot communicate with multiple phone apps" class="image" src="/connect-iq/resources/programmers-guide/ios-image9.png"/><br/></div></article></article></article></article></article></main></div>
</body>
</html>